import { ITimingSource } from "../Common/Interfaces/ITimingSource";
import { IMessageViewer } from "../Common/Interfaces/IMessageViewer";
import { IAudioPlayer } from "../Common/Interfaces/IAudioPlayer";
import { MusicPartManager } from "../MusicalScore/MusicParts";
import { Dictionary } from "typescript-collections";
import { VoiceEntry, MidiInstrument } from "../MusicalScore/VoiceData";
import { Instrument } from "../MusicalScore";
import { PlaybackNote } from "../MusicalScore/Playback/PlaybackNote";
import { IAudioMetronomePlayer } from "../Common/Interfaces/IAudioMetronomePlayer";
import { ISettableInstrument } from "../Common/Interfaces/ISettableInstrument";
import { PlaybackState } from "../Common/Enums/PsEnums";
import { IPlaybackListener } from "../Common/Interfaces/IPlaybackListener";
import { IPlaybackParametersListener } from "../Common/Interfaces/IPlaybackParametersListener";
export declare class ChannelNote {
    note: PlaybackNote;
    key: number;
    channel: number;
    constructor(k: number, c: number, n?: PlaybackNote);
}
export declare class PlaybackManager implements IPlaybackParametersListener {
    protected timingSource: ITimingSource;
    protected resetRequested: boolean;
    protected loopTriggeredReset: boolean;
    protected tempoUserFactor: number;
    protected currentBPM: number;
    protected listeners: IPlaybackListener[];
    addListener(listener: IPlaybackListener): void;
    private readonly percussionChannel;
    private messageViewer;
    private audioMetronomePlayer;
    private audioPlayer;
    private musicPartManager;
    private cursorIterator;
    private playbackIterator;
    private instrumentToStaffToMidiChannelDict;
    private instrumentIdMapping;
    get InstrumentIdMapping(): Dictionary<number, Instrument>;
    private freeMidiChannels;
    private notesToStop;
    private metronomeNote;
    private metronomeNoteFirstBeat;
    private currentMeasure;
    private currentTimestamp;
    private closestNextTimestamp;
    private currentMetronomeBaseTimestamp;
    private currentBeatDuration;
    private currentIteratorSourceTimeStamp;
    private beatCounter;
    protected runningState: PlaybackState;
    private isRunning;
    private isInitialized;
    private nextIteratorTimestamp;
    private playNextMetronomeAt;
    private isPlaying;
    private metronome;
    private metronomeSoundPlayed;
    private tempoImpactFactor;
    private sheetStartBPM;
    private currentReferenceBPM;
    private readonly defaultVolume;
    private currentVolume;
    private dynamicImpactFactor;
    private scorePositionChangedData;
    private tooManyInstruments;
    private currentRepetition;
    private currentMeasureIndex;
    private metronomeOnlyBPM;
    private readonly highlightPlayedNotes;
    private startRhythmBeats;
    private startRhythmDenominator;
    private isPreCounting;
    private fermataActive;
    private doPreCount;
    constructor(timingSource: ITimingSource, audioMetronomePlayer: IAudioMetronomePlayer, audioPlayer: IAudioPlayer<any>, messageViewer: IMessageViewer);
    get RunningState(): PlaybackState;
    set RunningState(value: PlaybackState);
    DoPlayback: boolean;
    /** Do the initial pre-count */
    get DoPreCount(): boolean;
    set DoPreCount(value: boolean);
    PreCountBeats: number;
    get Metronome(): ISettableInstrument;
    get MetronomeOnlyBPM(): number;
    set MetronomeOnlyBPM(value: number);
    get OriginalBpm(): number;
    /** will be activated when any solo flag of an Instrument, Voice or Staff is set to true. */
    SoloActive: boolean;
    SoloAttenuationValue: number;
    playVoiceEntry(voiceEntry: VoiceEntry): void;
    initialize(musicPartMng: MusicPartManager): void;
    play(): Promise<void>;
    pause(): Promise<void>;
    reset(): void;
    Dispose(): void;
    setSound(instrumentId: number, newSoundId: MidiInstrument): boolean;
    protected setBpm(bpm: number): void;
    handlePlaybackEvent(): void;
    private NotesPlaybackEventOccurred;
    calculateFinalVolume(volume: number): number;
    private loop;
    private stopAllCurrentlyPlayingNotes;
    protected doReset(shallPrecount: boolean): void;
    private calculateClosestNextTimestamp;
    protected handleEndReached(): void;
    private updateScoreCursorPosition;
    private stopMetronomeSound;
    private playMetronomeSound;
    private stopFinishedNotes;
    private processTempoInstructions;
    private handleFermata;
    bpmChanged(newBpm: number): void;
    volumeChanged(instrument: number, newVolume: number): void;
    volumeMute(instrument: number): void;
    volumeUnmute(instrument: number): void;
    private changeTempo;
    protected setTempo(): void;
    protected getCurrentReferenceBPM(): number;
    checkForSoloDeactivated(): void;
}
